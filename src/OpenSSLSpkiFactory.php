<?php
/**
 * OpenSSLToolbox   the PHP OpenSSL Toolbox
 *
 * This file is a part of OpenSSLToolbox.
 *
 * Copyright 2020 Kjell-Inge Gustafsson, kigkonsult, All rights reserved
 * author    Kjell-Inge Gustafsson, kigkonsult
 * Link      https://kigkonsult.se
 * Version   0.971
 * License   GNU Lesser General Public License version 3
 *
 *   Subject matter of licence is the software OpenSSLToolbox. The above
 *   copyright, link, package and version notices, this licence notice shall be
 *   included in all copies or substantial portions of the OpenSSLToolbox.
 *
 *   OpenSSLToolbox is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU Lesser General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or (at your
 *   option) any later version.
 *
 *   OpenSSLToolbox is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *   License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with OpenSSLToolbox. If not, see <https://www.gnu.org/licenses/>.
 *
 * Disclaimer of rights
 *
 *   Herein may exist software logic (hereafter solution(s)) found on internet
 *   (hereafter originator(s)). The rights of each solution belongs to
 *   respective originator;
 *
 *   Credits and acknowledgements to originators!
 *   Links to originators are found wherever appropriate.
 *
 *   Only OpenSSLToolbox copyright holder works, OpenSSLToolbox author(s) works
 *   and solutions derived works and OpenSSLToolbox collection of solutions are
 *   covered by GNU Lesser General Public License, above.
 */
namespace Kigkonsult\OpenSSLToolbox;

use Exception;
use InvalidArgumentException;
use Kigkonsult\LoggerDepot\LoggerDepot;
use Psr\Log\LogLevel;
use RuntimeException;

use function openssl_spki_export;
use function openssl_spki_export_challenge;
use function openssl_spki_new;
use function openssl_spki_verify;
use function sprintf;

/**
 * Class OpenSSLSpkiFactory
 *
 * Wrapper for PHP OpenSSL SPKI functions, encapsulates the SPKI (string) resource
 * Note: You need to have a valid openssl.cnf installed for this to operate correctly.
 * Require a Psr\Log logger, provided by LoggerDepot
 *
 * @todo improve
 */
class OpenSSLSpkiFactory extends OpenSSLBaseFactory
{
    /**
     * @var string   spkac without 'SPKAC='-$prefix
     */
    private $spkac = null;

    /**
     * Class constructor
     *
     * If argument privateKey and challenge are set, a new spkac is set
     * @param resource $privateKey   1. A private key, previously generated by openssl_pkey_new()
     *                                    (or otherwise obtained from the other openssl_pkey family of functions).
     *                               2. A string having the format (file://)path/to/file.pem.
     *                                  The named file must contain a PEM encoded certificate/private key (it may contain both).
     *                               3. A string, PEM formatted private key.
     * @param string   $challenge    To associate with the SPKAC
     * @param int      $algorithm    The digest algorithm. See openssl_get_md_method(). -- don't accepted
     *                                  MUST be one of Signature algorithms, https://www.php.net/manual/en/openssl.signature-algos.php
     *                                  NOTE :  (2) OPENSSL_ALGO_MD5, (3) OPENSSL_ALGO_MD4, (5) OPENSSL_ALGO_DSS1 don't verify ok
     * @throws InvalidArgumentException
     * @throws RunTimeException
     */
    public function __construct( $privateKey = null, $challenge = null, $algorithm = 0 ) {
        $this->logger  = LoggerDepot::getLogger( get_class() );
        $this->log(LogLevel::INFO, self::initClassStr());
        $setReady      = 0;
        if( ! empty( $privateKey )) {
            $setReady += 1;
        }
        if( ! empty( $challenge )) {
            $setReady += 2;
        }
        if( 3 == $setReady ) {
            $this->spkiNew( $privateKey, $challenge, $algorithm );
        }
    }

    /**
     * Class factory method
     *
     * @param resource $privateKey   1. A private key, previously generated by openssl_pkey_new()
     *                                    (or otherwise obtained from the other openssl_pkey family of functions).
     *                               2. A string having the format (file://)path/to/file.pem.
     *                                  The named file must contain a PEM encoded certificate/private key (it may contain both).
     *                               3. A string, PEM formatted private key.
     * @param string   $challenge       To associate with the SPKAC
     * @param int      $algorithm       The digest algorithm. See openssl_get_md_method(). -- don't accepted
     *                                  MUST be one of Signature algorithms, https://www.php.net/manual/en/openssl.signature-algos.php
     *                                  NOTE :  (2) OPENSSL_ALGO_MD5, (3) OPENSSL_ALGO_MD4, (5) OPENSSL_ALGO_DSS1 don't verify ok
     * @return static
     * @throws InvalidArgumentException
     * @throws RunTimeException
     * @access static
     */
    public static function factory( $privateKey = null, $challenge = null, $algorithm = 0 ) {
        return new self( $privateKey, $challenge, $algorithm );
    }

    /**
     * Return (exports) the associated PEM formatted public key - uses openssl_spki_export
     *
     * @link https://www.php.net/manual/en/function.openssl-spki-export.php
     * @return string
     * @throws RuntimeException
     */
    public function export() {
        $this->log( LogLevel::DEBUG, self::$INIT . self::getCm( __METHOD__ ));
        if( ! $this->isSpkiacSet()) {
            throw new RuntimeException( self::$FMTERR2 );
        }
        $result = null;
        self::clearOpenSSLErrors();
        set_error_handler( self::$ERRORHANDLER );
        try {
            $result = openssl_spki_export( $this->spkac );
        }
        catch( Exception $e ) {
            self::assessCatch( self::getCm( __METHOD__ ), $e, ( ! empty( $result )), self::getOpenSSLErrors());
        }
        finally {
            restore_error_handler();
        }
        if( empty( $result )) {
            self::logAndThrowRuntimeException( self::getCm( __METHOD__ ), null, self::getOpenSSLErrors() );
        }
        $this->log( LogLevel::DEBUG, self::$PASSED . self::getCm( __METHOD__ )); // test ###
        return $result;
    }

    /**
     * Return (exports) the associated PEM formatted public key - alias of export
     *
     * @return string
     * @throws RuntimeException
     */
    public function getSPKACasString() {
        return $this->export();
    }

    /**
     * Return (exports) the challenge associated with a signed public key and challenge - uses openssl_spki_export_challenge
     *
     * @link https://www.php.net/manual/en/function.openssl-spki-export-challenge.php
     * @return string
     * @throws RuntimeException
     */
    public function exportChallenge() {
        $this->log( LogLevel::DEBUG, self::$INIT . self::getCm( __METHOD__ ));
        if( ! $this->isSpkiacSet()) {
            throw new RuntimeException( self::$FMTERR2 );
        }
        $result = null;
        self::clearOpenSSLErrors();
        set_error_handler( self::$ERRORHANDLER );
        try {
            $result = openssl_spki_export_challenge( $this->spkac );
        }
        catch( Exception $e ) {
            self::assessCatch( self::getCm( __METHOD__ ), $e, ( ! empty( $result )), self::getOpenSSLErrors());
        }
        finally {
            restore_error_handler();
        }
        if( empty( $result )) {
            self::logAndThrowRuntimeException( self::getCm( __METHOD__ ), null, self::getOpenSSLErrors() );
        }
        $this->log( LogLevel::DEBUG, self::$PASSED . self::getCm( __METHOD__ )); // test ###
        return $result;
    }

    /**
     * Return (exports) the challenge associated with a signed public key and challenge - alias of exportChallenge
     *
     * @return string
     * @throws RuntimeException
     */
    public function getChallengeAsString() {
        return $this->exportChallenge();
    }

    /**
     * Generate and set a new signed public key and challenge - SPKI - uses openssl_spki_new
     *
     * @link https://www.php.net/manual/en/function.openssl-spki-new.php
     * @param resource $privateKey   1. A private key, previously generated by openssl_pkey_new()
     *                                    (or otherwise obtained from the other openssl_pkey family of functions).
     *                               2. A string having the format (file://)path/to/file.pem.
     *                                  The named file must contain a PEM encoded certificate/private key (it may contain both).
     *                               3. A string, PEM formatted private key.
     * @param string   $challenge       To associate with the SPKAC
     * @param int      $algorithm       The digest algorithm. See openssl_get_md_method(). -- don't accepted
     *                                  MUST be one of Signature algorithms, https://www.php.net/manual/en/openssl.signature-algos.php
     *                                  default 1, OPENSSL_ALGO_SHA1
     *                                  NOTE :  (2) OPENSSL_ALGO_MD5, (3) OPENSSL_ALGO_MD4, (5) OPENSSL_ALGO_DSS1 don't verify ok
     * @return static
     * @throws InvalidArgumentException
     * @throws RuntimeException
     */
    public function spkiNew( $privateKey, $challenge, $algorithm = 0 ) {
        static $FMTMSG = 'Algorithm set to (1) OPENSSL_ALGO_SHA1';
        static $FMTERR = 'Invalid algorithm %s';
        $this->log( LogLevel::DEBUG, self::$INIT . self::getCm( __METHOD__ ));
        $privateKey    = OpenSSLPkeyFactory::assertPkey( $privateKey, 1, true );
        if( is_string( $privateKey )) {
            $privateKey = OpenSSLPkeyFactory::getPrivate( $privateKey );
        }
        Assert::string( $challenge );
        switch( true ) {
            case empty( $algorithm ) :
                $algorithm = 1;
                $this->log( LogLevel::INFO, $FMTMSG );
                break;
            case ( isset( OpenSSLFactory::$SIGNATUREALGOS[$algorithm] )) :
                break;
            default :
                throw new InvalidArgumentException( sprintf( $FMTERR, $algorithm ));
                break;
        }
        $result = null;
        self::clearOpenSSLErrors();
        set_error_handler( self::$ERRORHANDLER );
        try {
            $result = openssl_spki_new( $privateKey, $challenge, $algorithm );
        }
        catch( Exception $e ) {
            self::assessCatch( self::getCm( __METHOD__ ), $e, ( ! empty( $result )), self::getOpenSSLErrors());
        }
        finally {
            restore_error_handler();
        }
        if( empty( $result )) {
            self::logAndThrowRuntimeException( self::getCm( __METHOD__ ), null, self::getOpenSSLErrors() );
        }
        $this->setSpkac( $result );
        $this->log( LogLevel::DEBUG, self::$PASSED . self::getCm( __METHOD__ )); // test ###
        return $this;
    }

    /**
     * Return bool true if a signed public key and challenge is verified ok - uses openssl_spki_verify
     *
     * NOTE :  (2) OPENSSL_ALGO_MD5, (3) OPENSSL_ALGO_MD4, (5) OPENSSL_ALGO_DSS1 don't verify ok
     * @link https://www.php.net/manual/en/function.openssl-spki-verify.php
     * @param string  $spkac     a valid(?) signed public key and challenge
     * @return bool
     * @static
     */
    public static function verify( $spkac ) {
        $logger = LoggerDepot::getLogger( get_called_class());
        $logger->log( LogLevel::DEBUG, self::$INIT . self::getCm( __METHOD__ ));
        Assert::string( $spkac );
        $spkac  = self::removePrefix( $spkac );
        $result = false;
        self::clearOpenSSLErrors();
        set_error_handler( self::$ERRORHANDLER );
        try {
            $result = openssl_spki_verify( $spkac );
        }
        catch( Exception $e ) {
            self::assessCatch( self::getCm( __METHOD__ ), $e, false, self::getOpenSSLErrors());
        }
        finally {
            restore_error_handler();
        }
        $logger->log( LogLevel::DEBUG, self::$PASSED . self::getCm( __METHOD__ )); // test ###
        return (bool) $result;
    }

    /** ***********************************************************************
     *  Getters and setters etc
     */

    /**
     * @var string
     */
    public static $prefix = 'SPKAC=';

    /**
     * Return spkac without prefix
     *
     * @param string $spkac
     * @return string
     */
    public static function removePrefix( $spkac ) {
        return ( self::$prefix == substr( $spkac, 0, 6 )) ? substr( $spkac, 6 ) : $spkac;
    }

    /**
     * Return SPKAC without leading 'SPKAC='
     * @return string
     */
    public function getSpkac() {
        return $this->spkac;
    }

    /**
     * @return bool
     */
    public function isSpkiacSet() {
        return ( ! empty( $this->spkac ));
    }

    /**
     * Set SPKAC (with removed prefix)
     * @param string  $spkac
     * @return static
     * @throws InvalidArgumentException
     */
    public function setSpkac( $spkac ) {
        $this->log( LogLevel::DEBUG, self::$INIT . self::getCm( __METHOD__ ));
        static $FMT  = 'Unsuccessfull verification of the spkac';
        Assert::string( $spkac );
        $spkac       = self::removePrefix( $spkac );
        if( ! self::verify( $spkac )) {
            throw new InvalidArgumentException( $FMT );
        }
        $this->spkac = $spkac;
        return $this;
    }

}
